<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<script type="module">

			import * as THREE from '../three.js-master/build/three.module.js';
			import {OrbitControls} from '../three.js-master/examples/jsm/controls/OrbitControls.js';

			let camera, scene, renderer;
			let controls;
			let columns;
			let stairs;
			let roof;
			let ambientLight, light, lightHelper;
			let stone, outerStone, marble, base;

			init();
			animate();

			//____INIT________________________________________________
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 20000 );
				scene = new THREE.Scene();

				// renderer & material
				setRenderer();
				createMaterials();

				//	Orbit Controls & light
				createControls();
				createLight();

				//	Temple
				createTemple();


				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

			}


			//____ONWINDOWRESIZE_________________________________________
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			//____ANIMATE_________________________________________________
			function animate() {

				requestAnimationFrame( animate );
				renderer.render( scene, camera );

			}



			//____FUNCTIONS_________________________________________________

				//---	Rendrer & OrbitControls -----------------

			function setRenderer(){
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMap.enabled = true ;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;
			}

			function createControls(){
				controls = new OrbitControls( camera, renderer.domElement );

				controls.enabledDamping = true;
				controls.dampingFactor = 0.05;
				controls.screenPanning = false;

				controls.minDistance = 500;
				controls.maxDistance = 5000;

				controls.maxPolarAngle = Math.PI / 2;
				controls.target = new THREE.Vector3(600,0,-1800);
			}


				//---	Materials --------------------------------

			function createMaterials(){
				const stoneTxt = new THREE.TextureLoader().load( 'assets/stone.jpg' );
				stoneTxt.wrapS = THREE.RepeatWrapping ;
				stoneTxt.wrapT = THREE.RepeatWrapping;
				stoneTxt.repeat.set( 12, 10 );
				stone = new THREE.MeshPhongMaterial( { map: stoneTxt} );

				const outerStoneTxt = new THREE.TextureLoader().load( 'assets/stone.jpg' );
				outerStoneTxt.wrapS = THREE.RepeatWrapping ;
				outerStoneTxt.wrapT = THREE.RepeatWrapping;
				outerStoneTxt.repeat.set( 10, 5 );
				outerStone = new THREE.MeshPhongMaterial( { map: outerStoneTxt} );


				const marbleTxt = new THREE.TextureLoader().load( 'assets/marble.jpg' );
				marbleTxt.wrapS = THREE.RepeatWrapping ;
				marbleTxt.repeat.set( 4, 4 );
				marble = new THREE.MeshPhongMaterial( { map: marbleTxt} );

				const baseTxt = new THREE.TextureLoader().load( 'assets/base.png' );
				baseTxt.wrapS = THREE.RepeatWrapping ;
				baseTxt.wrapT = THREE.RepeatWrapping;
				baseTxt.repeat.set( 1, 1 );
				base = new THREE.MeshPhongMaterial( { map: baseTxt} );
			}

				//---	Light ------------------------------------

			function createLight () {
				ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
				scene.add(ambientLight) ;

				light = new THREE.SpotLight( 0xffffff, 1 );
				light.position.set(0, 5000, -10000 );
				light.castShadow = true;

				lightHelper = new THREE.SpotLightHelper( light );
				scene.add( lightHelper );
				scene.add( light );
			}


				//--- Mesh -----------------------------------------
			/*
			Creates a mesh from a box geometry
			x, y, z 				Dimensions of the box
			material 				Texture of the mesh
			rot_x, rot_y, rot_z		Rotation applied to the object
			*/
			function createRectangleMesh (x, y, z, material, rot_x, rot_y, rot_z) {
				let rectGeom = new THREE.BoxBufferGeometry( x, y, z );
				let rect = new THREE.Mesh( rectGeom, material );
				rect.rotation.x += rot_x ;
				rect.rotation.y += rot_y ;
				rect.rotation.z += rot_z ;
				return rect ;
			}


			/*
			Adds offsets to the position of an object
			object 					Object (type : new THREE.Mesh)
			off_x, off_y, off_z		Offsets added to each direction
			*/
			function addToPosition (object, off_x, off_y, off_z) {
				object.position.x += off_x ;
				object.position.y += off_y ;
				object.position.z += off_z ;
				return object ;
			}


			//########		TEMPLE		################################

				//--- createTemple -------------------------------

			function createTemple(){
				createColumns();
				createStairs();
				createRoof();
			}

				//---	Columns ------------------------------------

			function createColumns(){
				let col, down_col, top_col, column, columns;
				let arr_columns = new Array(8).fill(new Array(18));

				column = setColumn();

				columns = new THREE.Group();

				let offset_x = 0;
				let offset_z = 0;
				// rectangle of 8 x 18 columns
						for (let i = 0; i < 8; i++) {
					offset_x = 200 * i;
					for (let j = 0; j < 18; j++) {
						offset_z = -200 * j;
						if(i===0 || i===7) {
							arr_columns[i][j] = column.clone();
							arr_columns[i][j].position.x = offset_x;
									arr_columns[i][j].position.z = offset_z;
										columns.add(arr_columns[i][j]);
						}
						if(j===0 || j===17) {
							arr_columns[i][j] = column.clone();
										arr_columns[i][j].position.x = offset_x;
							arr_columns[i][j].position.z = offset_z;
										columns.add(arr_columns[i][j]);
						}
					}
						}
				scene.add( columns );
			}

			function setColumn(){
				let col, top_col, column;

				const cylinder = new THREE.CylinderBufferGeometry( 35, 60, 850, 10 );

				col = new THREE.Mesh( cylinder, marble );
				col.castShadow = true ;

				top_col = setTopColumn();
				column = new THREE.Group().add(col, top_col);

				return column;
			}

			function setTopColumn(){
				let top_col;

				//SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
				const sphere = new THREE.SphereBufferGeometry( 180, 4, 2, 3.14/4, 6.3, 0.2, 0.7);
				top_col = new THREE.Mesh( sphere, base );
				top_col.position.y += 550;
				top_col.rotation.x = Math.PI;
				top_col.castShadow = true ;
				return top_col;
			}


				//--- Stairs ----------------------------------------

			function createStairs () {
				let width ;
				let depth ;
				let height = 30;
				let arr_stairs = new Array(3) ;

				stairs = new THREE.Group();
				for (let i = 0 ; i < 6 ; ++i) {
					width = 1800 + i * 75 ;
					depth = 3800 + i * 100 ;
					arr_stairs[i] = createRectangleMesh(width, height, depth, stone, 0, 0, 0) ;
					arr_stairs[i].position.y = -(height * i) - 400 ;
					arr_stairs[i].position.x = 700 ;
					arr_stairs[i].position.z = -1700 ;
					arr_stairs[i].recieveShadow = true ;
					stairs.add(arr_stairs[i]) ;
				}
				stairs.recieveShadow = true ;
				scene.add( stairs );
			}


				//---	Roof ------------------------------------------------

			function createRoof () {
				let roof_base, roof_mid, roof_top_r, roof_top_l;

				let offset_x = 0;
				let offset_z = 0;
				roof = new THREE.Group() ;

				roof_base = createRectangleMesh(1600, 200, 3600, outerStone, 0, 0, 0) ;
				roof_base.castShadow = true ;
				roof.add( roof_base ) ;

				roof_mid = createRectangleMesh(1600, 50, 3650, outerStone, 0, 0, 0) ;
				roof_mid.position.y += 100 ;
				roof.add( roof_mid ) ;

				//Roof angled pannels
				offset_x = 380 ;
				roof_top_r = createRectangleMesh(831, 50, 3625, stone, 0, 0, -3.5) ;
				roof_top_r = addToPosition(roof_top_r, offset_x, 250, 0) ;
				roof.add( roof_top_r ) ;
				roof_top_l = createRectangleMesh(831, 50, 3625, stone, 0, 0, 3.5) ;
				roof_top_l = addToPosition(roof_top_l, -offset_x, 250, 0) ;
				roof.add( roof_top_l ) ;

				roof_triangles();

				//Roof setup
				roof = addToPosition(roof, 700, 525, -1700) ;

				roof.castShadow = true ;
				scene.add( roof ) ;
			}

			function roof_triangles(){
				let roof_pane_f, roof_pane_b, roof_pane ;

				roof_pane = new THREE.Geometry();
				let v1 = new THREE.Vector3(-800, 0, 0);
				let v2 = new THREE.Vector3(800, 0, 0);
				let v3 = new THREE.Vector3(0, 300, 0);
				let triangle = new THREE.Triangle(v1, v2, v3);
				let normal = triangle.getNormal();
				roof_pane.vertices.push(
					triangle.a,
					triangle.b,
					triangle.c
				);
				roof_pane.faces.push(new THREE.Face3(0, 1, 2, normal));

				roof_pane_f = new THREE.Mesh(roof_pane, stone);
				roof_pane_f = addToPosition(roof_pane_f, 0, 100, 1800) ;
				roof.add(roof_pane_f);
				roof_pane_b = new THREE.Mesh(roof_pane, stone);
				roof_pane_f = addToPosition(roof_pane_b, 0, 100, -1800) ;
				roof_pane_b.rotation.y += Math.PI;
				roof.add(roof_pane_b);
			}


		</script>

	</body>
</html>
